// Generated by CoffeeScript 1.6.3
(function() {
  window.WebGLHelpers = {
    handleLoadedTexture: function(gl, glTexture, image) {
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
      gl.generateMipmap(gl.TEXTURE_2D);
      return gl.bindTexture(gl.TEXTURE_2D, null);
    },
    initTexture: function(gl, texturePath, onLoad) {
      var glTexture, image,
        _this = this;
      glTexture = gl.createTexture();
      image = new Image();
      image.onload = function() {
        _this.handleLoadedTexture(gl, glTexture, image);
        return onLoad(glTexture);
      };
      return image.src = texturePath;
    },
    getWebGLContext: function(canvas) {
      var contextNames, gl, name, _i, _len;
      contextNames = ['experimental-webgl', 'webgl'];
      for (_i = 0, _len = contextNames.length; _i < _len; _i++) {
        name = contextNames[_i];
        gl = canvas.getContext(name);
        if (gl) {
          break;
        }
      }
      if (!gl) {
        alert('Could not create a WebGL context!');
        return null;
      }
      return gl;
    },
    getShaderFromDOM: function(gl, elementID) {
      var el, shader, shaderSource;
      el = document.getElementById(elementID);
      if (!el) {
        alert("Element #" + elementID + " could not be found!");
        return null;
      }
      shaderSource = el.textContent;
      if (el.type === 'shader-x/vertex') {
        shader = gl.createShader(gl.VERTEX_SHADER);
      } else if (el.type === 'shader-x/fragment') {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
      }
      gl.shaderSource(shader, shaderSource);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    },
    createProgram: function(gl, vertexShader, fragmentShader) {
      var program;
      program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        alert(gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }
  };

}).call(this);
