// Generated by CoffeeScript 1.6.3
(function() {
  var __slice = [].slice;

  window.GLCubeHelper = (function() {
    GLCubeHelper.VERTEX_SIZE = 3;

    GLCubeHelper.NORMAL_SIZE = 3;

    GLCubeHelper.TEXTURE_COORD_SIZE = 2;

    function GLCubeHelper(gl, lightDirection, lightColor, ambientColor, onReady) {
      var fragmentShader, vertexShader,
        _this = this;
      this.gl = gl;
      this.lightDirection = lightDirection;
      this.lightColor = lightColor;
      this.ambientColor = ambientColor;
      vertexShader = WebGLHelpers.getShaderFromDOM(gl, 'cube-vertex');
      fragmentShader = WebGLHelpers.getShaderFromDOM(gl, 'cube-fragment');
      this.program = WebGLHelpers.createProgram(gl, vertexShader, fragmentShader);
      vec3.normalize(this.lightDirection, this.lightDirection);
      vec3.scale(this.lightDirection, this.lightDirection, -1);
      this.program.vertexPosLocation = gl.getAttribLocation(this.program, 'a_vertexPos');
      this.program.vertexTextureLocation = gl.getAttribLocation(this.program, 'a_textureCoord');
      this.program.vertexNormalLocation = this.gl.getAttribLocation(this.program, 'a_vertexNormal');
      gl.enableVertexAttribArray(this.program.vertexPosLocation);
      gl.enableVertexAttribArray(this.program.vertexTextureLocation);
      gl.enableVertexAttribArray(this.program.vertexNormalLocation);
      this.program.mvMatrixLocation = gl.getUniformLocation(this.program, 'u_mvMatrix');
      this.program.pMatrixLocation = gl.getUniformLocation(this.program, 'u_pMatrix');
      this.program.nMatrixLocation = gl.getUniformLocation(this.program, 'u_nMatrix');
      this.program.samplerLocation = gl.getUniformLocation(this.program, 'u_sampler');
      this.program.ambientColorLocation = gl.getUniformLocation(this.program, 'u_ambientColor');
      this.program.lightingDirectionLocation = gl.getUniformLocation(this.program, 'u_lightingDirection');
      this.program.directionalColorLocation = gl.getUniformLocation(this.program, 'u_directionalColor');
      WebGLHelpers.initTexture(gl, 'textures/stonebricksmooth_carved.png', function(glTexture) {
        _this.texture = glTexture;
        return onReady(_this);
      });
    }

    GLCubeHelper.prototype.draw = function(mvMatrix, pMatrix, vertexPosBuffer, indexBuffer, textureCoordBuffer, normalBuffer) {
      var normalMatrix, _ref, _ref1;
      this.gl.useProgram(this.program);
      this.gl.uniformMatrix4fv(this.program.mvMatrixLocation, false, mvMatrix);
      this.gl.uniformMatrix4fv(this.program.pMatrixLocation, false, pMatrix);
      normalMatrix = mat3.create();
      mat3.fromMat4(normalMatrix, mvMatrix);
      mat3.invert(normalMatrix, normalMatrix);
      mat3.transpose(normalMatrix, normalMatrix);
      this.gl.uniformMatrix3fv(this.program.nMatrixLocation, false, normalMatrix);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexPosBuffer);
      this.gl.vertexAttribPointer(this.program.vertexPosLocation, GLCubeHelper.VERTEX_SIZE, this.gl.FLOAT, false, 0, 0);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, normalBuffer);
      this.gl.vertexAttribPointer(this.program.vertexNormalLocation, GLCubeHelper.NORMAL_SIZE, this.gl.FLOAT, false, 0, 0);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, textureCoordBuffer);
      this.gl.vertexAttribPointer(this.program.vertexTextureLocation, GLCubeHelper.TEXTURE_COORD_SIZE, this.gl.FLOAT, false, 0, 0);
      this.gl.uniform3fv(this.program.lightingDirectionLocation, this.lightDirection);
      (_ref = this.gl).uniform3f.apply(_ref, [this.program.directionalColorLocation].concat(__slice.call(this.lightColor)));
      (_ref1 = this.gl).uniform3f.apply(_ref1, [this.program.ambientColorLocation].concat(__slice.call(this.ambientColor)));
      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
      this.gl.uniform1i(this.program.samplerUniform, 0);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      return this.gl.drawElements(this.gl.TRIANGLES, indexBuffer.numItems, this.gl.UNSIGNED_SHORT, 0);
    };

    GLCubeHelper.prototype.getGLBufferFromArray = function(array, indexBuffer) {
      var newBuffer;
      if (indexBuffer == null) {
        indexBuffer = false;
      }
      newBuffer = this.gl.createBuffer();
      if (indexBuffer) {
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, newBuffer);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(array), this.gl.STATIC_DRAW);
      } else {
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, newBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(array), this.gl.STATIC_DRAW);
      }
      return newBuffer;
    };

    GLCubeHelper.prototype.addVerticesAtPos = function(array, x, y, z, w, faces) {
      var addedVertices;
      if (w == null) {
        w = 1;
      }
      if (faces == null) {
        faces = {
          all: true
        };
      }
      w /= 2;
      addedVertices = 0;
      if (faces['front'] || faces['all']) {
        addedVertices += 4;
        array.push(-w + x, -w + y, w + z, w + x, -w + y, w + z, w + x, w + y, w + z, -w + x, w + y, w + z);
      }
      if (faces['back'] || faces['all']) {
        addedVertices += 4;
        array.push(-w + x, -w + y, -w + z, -w + x, w + y, -w + z, w + x, w + y, -w + z, w + x, -w + y, -w + z);
      }
      if (faces['top'] || faces['all']) {
        addedVertices += 4;
        array.push(-w + x, w + y, -w + z, -w + x, w + y, w + z, w + x, w + y, w + z, w + x, w + y, -w + z);
      }
      if (faces['bottom'] || faces['all']) {
        addedVertices += 4;
        array.push(-w + x, -w + y, -w + z, w + x, -w + y, -w + z, w + x, -w + y, w + z, -w + x, -w + y, w + z);
      }
      if (faces['right'] || faces['all']) {
        addedVertices += 4;
        array.push(w + x, -w + y, -w + z, w + x, w + y, -w + z, w + x, w + y, w + z, w + x, -w + y, w + z);
      }
      if (faces['left'] || faces['all']) {
        addedVertices += 4;
        array.push(-w + x, -w + y, -w + z, -w + x, -w + y, w + z, -w + x, w + y, w + z, -w + x, w + y, -w + z);
      }
      return addedVertices;
    };

    GLCubeHelper.prototype.addVertexNormals = function(array, faces) {
      var addedNormals;
      if (faces == null) {
        faces = {
          all: true
        };
      }
      addedNormals = 0;
      if (faces['front'] || faces['all']) {
        addedNormals += 4;
        array.push(0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);
      }
      if (faces['back'] || faces['all']) {
        addedNormals += 4;
        array.push(0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0);
      }
      if (faces['top'] || faces['all']) {
        addedNormals += 4;
        array.push(0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0);
      }
      if (faces['bottom'] || faces['all']) {
        addedNormals += 4;
        array.push(0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0);
      }
      if (faces['right'] || faces['all']) {
        addedNormals += 4;
        array.push(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
      }
      if (faces['left'] || faces['all']) {
        addedNormals += 4;
        array.push(-1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0);
      }
      return addedNormals;
    };

    GLCubeHelper.prototype.addTextureCoords = function(array, faces) {
      if (faces == null) {
        faces = {
          all: true
        };
      }
      if (faces['front'] || faces['all']) {
        array.push(0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0);
      }
      if (faces['back'] || faces['all']) {
        array.push(1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0);
      }
      if (faces['top'] || faces['all']) {
        array.push(0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0);
      }
      if (faces['bottom'] || faces['all']) {
        array.push(1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0);
      }
      if (faces['right'] || faces['all']) {
        array.push(1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0);
      }
      if (faces['left'] || faces['all']) {
        return array.push(0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0);
      }
    };

    GLCubeHelper.prototype.addVertexIndices = function(array, o, faces) {
      var addedIndices, indices;
      if (o == null) {
        o = 0;
      }
      if (faces == null) {
        faces = {
          all: true
        };
      }
      addedIndices = 0;
      indices = [[o + 0, o + 1, o + 2, o + 0, o + 2, o + 3], [o + 4, o + 5, o + 6, o + 4, o + 6, o + 7], [o + 8, o + 9, o + 10, o + 8, o + 10, o + 11], [o + 12, o + 13, o + 14, o + 12, o + 14, o + 15], [o + 16, o + 17, o + 18, o + 16, o + 18, o + 19], [o + 20, o + 21, o + 22, o + 20, o + 22, o + 23]];
      if (faces['front'] || faces['all']) {
        array.push.apply(array, indices[addedIndices / 6]);
        addedIndices += 6;
      }
      if (faces['back'] || faces['all']) {
        array.push.apply(array, indices[addedIndices / 6]);
        addedIndices += 6;
      }
      if (faces['top'] || faces['all']) {
        array.push.apply(array, indices[addedIndices / 6]);
        addedIndices += 6;
      }
      if (faces['bottom'] || faces['all']) {
        array.push.apply(array, indices[addedIndices / 6]);
        addedIndices += 6;
      }
      if (faces['right'] || faces['all']) {
        array.push.apply(array, indices[addedIndices / 6]);
        addedIndices += 6;
      }
      if (faces['left'] || faces['all']) {
        array.push.apply(array, indices[addedIndices / 6]);
        addedIndices += 6;
      }
      return addedIndices;
    };

    return GLCubeHelper;

  })();

}).call(this);
