// Generated by CoffeeScript 1.6.3
(function() {
  var Block, Chunk;

  window.ChunkManager = (function() {
    function ChunkManager(glCubeHelper, xGridSize, yGridSize, zGridSize) {
      this.glCubeHelper = glCubeHelper;
      this.xGridSize = xGridSize;
      this.yGridSize = yGridSize;
      this.zGridSize = zGridSize;
      this.blocks = [[[]]];
      this.blockList = [];
      this._chunks = [];
    }

    ChunkManager.prototype.updateAndDraw = function(mvMatrix, pMatrix) {
      var chunk, _i, _len, _ref, _results;
      _ref = this._chunks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        chunk = _ref[_i];
        chunk.update();
        _results.push(chunk.render(mvMatrix, pMatrix));
      }
      return _results;
    };

    ChunkManager.prototype.getClosestBlockHitByRay = function(rpos, rview) {
      var block, hit, intersect, _i, _len, _ref;
      hit = {
        dist: Infinity
      };
      _ref = this.blockList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        block = _ref[_i];
        if (block.isActive) {
          intersect = block.getSideIntersectedByRay(rpos, rview);
          if ((intersect != null ? intersect.dist : void 0) < hit.dist) {
            hit = intersect;
            hit.block = block;
          }
        }
      }
      return hit;
    };

    ChunkManager.prototype.addBlock = function(rpos, rview) {
      var hit, sideToAddBlockTo, surroundingBlocks;
      hit = this.getClosestBlockHitByRay(rpos, rview);
      if (hit.block) {
        surroundingBlocks = this.getSurroundingBlocks(hit.block);
        sideToAddBlockTo = surroundingBlocks[hit.side];
        if (sideToAddBlockTo) {
          return sideToAddBlockTo.setActive(true);
        }
      }
    };

    ChunkManager.prototype.removeBlock = function(rpos, rview) {
      var block, hit, side, surroundingBlocks, _results;
      hit = this.getClosestBlockHitByRay(rpos, rview);
      if (hit.block) {
        hit.block.setActive(false);
        surroundingBlocks = this.getSurroundingBlocks(hit.block);
        _results = [];
        for (side in surroundingBlocks) {
          block = surroundingBlocks[side];
          if (block && block.isActive) {
            _results.push(block.chunker.needsUpdating = true);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    ChunkManager.prototype.getSurroundingBlocks = function(block) {
      var blocks, x, y, z, _ref, _ref1, _ref2, _ref3;
      x = block.x;
      y = block.y;
      z = block.z;
      blocks = {};
      blocks['right'] = ((_ref = this.blocks[x + 1]) != null ? _ref[z][y] : void 0) || null;
      blocks['left'] = ((_ref1 = this.blocks[x - 1]) != null ? _ref1[z][y] : void 0) || null;
      blocks['front'] = ((_ref2 = this.blocks[x][z + 1]) != null ? _ref2[y] : void 0) || null;
      blocks['back'] = ((_ref3 = this.blocks[x][z - 1]) != null ? _ref3[y] : void 0) || null;
      blocks['top'] = this.blocks[x][z][y + 1] || null;
      blocks['bottom'] = this.blocks[x][z][y - 1] || null;
      return blocks;
    };

    ChunkManager.prototype.getVisibleFaces = function(b0) {
      var block, blocks, side, visibleFaces;
      blocks = this.getSurroundingBlocks(b0);
      visibleFaces = {};
      for (side in blocks) {
        block = blocks[side];
        if (!block || !block.isActive) {
          visibleFaces[side] = true;
        }
      }
      return visibleFaces;
    };

    ChunkManager.prototype.createLandscape = function(seed) {
      var active, block, chunk, height, noiseSize, x, y, z, _i, _ref, _results;
      if (seed == null) {
        seed = 0.7;
      }
      this.blocks = [];
      this.blockList = [];
      this._chunks = [];
      noiseSize = 6;
      _results = [];
      for (x = _i = 0, _ref = this.xGridSize; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        this.blocks.push([]);
        chunk = new Chunk(this.glCubeHelper, this);
        this._chunks.push(chunk);
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (z = _j = 0, _ref1 = this.zGridSize; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; z = 0 <= _ref1 ? ++_j : --_j) {
            this.blocks[x].push([]);
            height = this.yGridSize * PerlinNoise.noise(noiseSize * x / this.xGridSize, seed, noiseSize * z / this.zGridSize);
            height = Math.round(Math.pow(Math.log(height), 2.2));
            _results1.push((function() {
              var _k, _ref2, _results2;
              _results2 = [];
              for (y = _k = 0, _ref2 = this.yGridSize; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; y = 0 <= _ref2 ? ++_k : --_k) {
                active = y <= height;
                block = new Block(x, y, z, active);
                this.blocks[x][z].push(block);
                this.blockList.push(block);
                _results2.push(chunk.addBlock(block));
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return ChunkManager;

  })();

  Chunk = (function() {
    function Chunk(glCubeHelper, manager) {
      this.glCubeHelper = glCubeHelper;
      this.manager = manager;
      this._blocks = [];
      this.needsUpdating = true;
    }

    Chunk.prototype.addBlock = function(block) {
      block.addChunker(this);
      return this._blocks.push(block);
    };

    Chunk.prototype.updateMeshData = function() {
      var block, faces, indexCount, indexOffset, textCoords, vertIndices, vertNormals, vertices, _i, _len, _ref;
      vertices = [];
      vertIndices = [];
      vertNormals = [];
      textCoords = [];
      indexCount = 0;
      indexOffset = 0;
      _ref = this._blocks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        block = _ref[_i];
        if (block.isActive) {
          faces = this.manager.getVisibleFaces(block);
          if (Object.keys(faces).length > 0) {
            this.glCubeHelper.addTextureCoords(textCoords, faces);
            this.glCubeHelper.addVertexNormals(vertNormals, faces);
            indexCount += this.glCubeHelper.addVertexIndices(vertIndices, indexOffset, faces);
            indexOffset += this.glCubeHelper.addVerticesAtPos(vertices, block.x, block.y, block.z, Block.RENDER_SIZE, faces);
          }
        }
      }
      this._vertBuffer = this.glCubeHelper.getGLBufferFromArray(vertices);
      this._textCoordBuffer = this.glCubeHelper.getGLBufferFromArray(textCoords);
      this._vertNormalBuffer = this.glCubeHelper.getGLBufferFromArray(vertNormals);
      this._vertIndexBuffer = this.glCubeHelper.getGLBufferFromArray(vertIndices, true);
      return this._vertIndexBuffer.numItems = indexCount;
    };

    Chunk.prototype.update = function() {
      if (this.needsUpdating) {
        this.needsUpdating = false;
        return this.updateMeshData();
      }
    };

    Chunk.prototype.render = function(mvMatrix, pMatrix) {
      return this.glCubeHelper.draw(mvMatrix, pMatrix, this._vertBuffer, this._vertIndexBuffer, this._textCoordBuffer, this._vertNormalBuffer);
    };

    return Chunk;

  })();

  Block = (function() {
    Block.RENDER_SIZE = 1;

    function Block(x, y, z, isActive) {
      var d;
      this.x = x;
      this.y = y;
      this.z = z;
      this.isActive = isActive != null ? isActive : true;
      d = Block.RENDER_SIZE / 2;
      this.min = [x - d, y - d, z - d];
      this.max = [x + d, y + d, z + d];
    }

    Block.prototype.addChunker = function(chunker) {
      this.chunker = chunker;
    };

    Block.prototype.setActive = function(newState) {
      if (this.isActive !== newState) {
        this.isActive = newState;
        return this.chunker.needsUpdating = true;
      }
    };

    Block.prototype.getSideIntersectedByRay = (function() {
      var getPointOnPlane, sideNormals;
      sideNormals = {
        top: [0, 1, 0],
        bottom: [0, -1, 0],
        right: [1, 0, 0],
        left: [-1, 0, 0],
        front: [0, 0, 1],
        back: [0, 0, -1]
      };
      getPointOnPlane = function(pnormal, poffset, rpos, rview) {
        var intersectPos, t, v0, vd;
        vec3.normalize(rview, rview);
        vd = vec3.dot(pnormal, rview);
        if (Math.abs(vd) < 0.01) {
          return false;
        }
        v0 = -(vec3.dot(pnormal, rpos) - poffset);
        t = v0 / vd;
        if (t < 0) {
          return false;
        }
        intersectPos = vec3.add([], rpos, vec3.scale([], rview, t));
        return {
          pos: intersectPos,
          t: t
        };
      };
      return function(pos, view) {
        var offset, p;
        offset = this.max[1];
        if (pos[1] > offset) {
          p = getPointOnPlane(sideNormals.top, offset, pos, view);
          if (p && p.pos[0] < this.max[0] && p.pos[0] > this.min[0] && p.pos[2] < this.max[2] && p.pos[2] > this.min[2]) {
            return {
              side: 'top',
              dist: p.t
            };
          }
        }
        offset = this.min[1];
        if (pos[1] < offset) {
          offset *= -1;
          p = getPointOnPlane(sideNormals.bottom, offset, pos, view);
          if (p && p.pos[0] < this.max[0] && p.pos[0] > this.min[0] && p.pos[2] < this.max[2] && p.pos[2] > this.min[2]) {
            return {
              side: 'bottom',
              dist: p.t
            };
          }
        }
        offset = this.max[0];
        if (pos[0] > offset) {
          p = getPointOnPlane(sideNormals.right, offset, pos, view);
          if (p && p.pos[1] < this.max[1] && p.pos[1] > this.min[1] && p.pos[2] < this.max[2] && p.pos[2] > this.min[2]) {
            return {
              side: 'right',
              dist: p.t
            };
          }
        }
        offset = this.min[0];
        if (pos[0] < offset) {
          offset *= -1;
          p = getPointOnPlane(sideNormals.left, offset, pos, view);
          if (p && p.pos[1] < this.max[1] && p.pos[1] > this.min[1] && p.pos[2] < this.max[2] && p.pos[2] > this.min[2]) {
            return {
              side: 'left',
              dist: p.t
            };
          }
        }
        offset = this.max[2];
        if (pos[2] > offset) {
          p = getPointOnPlane(sideNormals.front, offset, pos, view);
          if (p && p.pos[1] < this.max[1] && p.pos[1] > this.min[1] && p.pos[0] < this.max[0] && p.pos[0] > this.min[0]) {
            return {
              side: 'front',
              dist: p.t
            };
          }
        }
        offset = this.min[2];
        if (pos[2] < offset) {
          offset *= -1;
          p = getPointOnPlane(sideNormals.back, offset, pos, view);
          if (p && p.pos[1] < this.max[1] && p.pos[1] > this.min[1] && p.pos[0] < this.max[0] && p.pos[0] > this.min[0]) {
            return {
              side: 'back',
              dist: p.t
            };
          }
        }
        return false;
      };
    })();

    return Block;

  })();

}).call(this);
